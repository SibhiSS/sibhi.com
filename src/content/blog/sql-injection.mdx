---
title: "Understanding SQL Injection: Boolean-based & Time-based"
date: "2025-09-15"
description: "A professional deep dive into advanced blind SQL Injection inference techniques."
tags: ["Web Security", "SQL Injection", "OWASP"]
difficulty: "Intermediate"
---

SQL Injection (SQLi) remains a critical vulnerability in modern web applications. While error-based SQLi is easily detected, **Blind SQL Injection** requires inferential techniques to exfiltrate data.

## Boolean-based Inference

In Boolean-based SQLi, the attacker relies on the application's response (HTTP 200 vs 404, or content difference) to infer whether a query returns TRUE or FALSE.

```sql
-- Payload to test TRUE condition
' AND 1=1 --
-- Result: Page loads normally

-- Payload to test FALSE condition
' AND 1=2 --
-- Result: Page missing content or returns error
```

If the Content-Length or response body changes, we can write a script to iterate through characters:

```python
# Pseudo-code for character inference
if response_length(payload) == true_length:
    print("Character match found!")
```

## Time-based Inference

When the application suppresses all errors and content variations, **Time-based SQLi** uses database sleep functions to confirm injection.

```sql
-- MySQL Sleep Injection
'; SELECT SLEEP(5); --

-- PostgreSQL Sleep Injection
'; PG_SLEEP(5); --
```

If the HTTP response time exceeds 5000ms, the injection is successful.

> [!WARNING]
> These techniques generate significant log noise. In a real engagement, use with caution to avoid WAF blocking.

## Remediation

The only reliable defense is **Parameterized Queries** (Prepared Statements) which separate code from data.

```javascript
// Secure Implementation (Node.js/pg)
const query = "SELECT * FROM users WHERE id = $1";
const values = [req.body.id];
await db.query(query, values);
```
